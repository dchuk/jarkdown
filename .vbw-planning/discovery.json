{
  "answered": [
    {
      "question": "How should time tracking data be placed in the output?",
      "answer": "Frontmatter fields: original_estimate, time_spent, remaining_estimate, progress. Uses Jira's human-readable format.",
      "area": "frontmatter-vs-body",
      "phase": "01",
      "date": "2026-02-17"
    },
    {
      "question": "How should the environment field be handled?",
      "answer": "Always as a body section (## Environment), even for short plain-text values. Consistent rendering.",
      "area": "frontmatter-vs-body",
      "phase": "01",
      "date": "2026-02-17"
    },
    {
      "question": "How should linked issues be rendered?",
      "answer": "Grouped by relationship type using ### sub-headings. Each link: [KEY](url): Summary (Status). Uses inward/outward directional labels.",
      "area": "issue-link-rendering",
      "phase": "01",
      "date": "2026-02-17"
    },
    {
      "question": "How detailed should worklog rendering be?",
      "answer": "Full markdown table with columns: Author, Time Spent, Date, Comment. Total time logged summary above table. ADF comments stripped to plain text.",
      "area": "worklog-depth",
      "phase": "01",
      "date": "2026-02-17"
    },
    {
      "question": "How should empty/null fields be handled?",
      "answer": "All fields always present. Frontmatter nulls use YAML null keyword, zeros show 0. Empty body sections show 'None'. Complete schema approach.",
      "area": "empty-field-handling",
      "phase": "01",
      "date": "2026-02-17"
    },
    {
      "question": "How should null frontmatter values be represented in YAML?",
      "answer": "YAML null keyword. Python yaml.safe_load parses as None. Explicit and unambiguous.",
      "area": "empty-field-handling",
      "phase": "01",
      "date": "2026-02-17"
    },
    {
      "question": "How should custom field IDs be resolved to display names?",
      "answer": "Cached field metadata in ~/.config/jarkdown/ per domain, 24h TTL with timestamp in filename. Degrade to raw IDs with warning if stale and API unreachable.",
      "area": "custom-field-discovery",
      "phase": "02",
      "date": "2026-02-17"
    },
    {
      "question": "What should the default behavior for custom fields be?",
      "answer": "Include all custom fields with non-null values by default. .jarkdown.toml config for persistent include/exclude lists. CLI --include-fields/--exclude-fields for per-run overrides.",
      "area": "custom-field-selection",
      "phase": "02",
      "date": "2026-02-17"
    },
    {
      "question": "Which ADF nodes should be covered in Phase 2?",
      "answer": "Full coverage: table, panel, expand, emoji, inlineCard, taskList/taskItem, decisionList/decisionItem, status, date, rule. Best-effort Markdown only, no HTML fallbacks.",
      "area": "adf-coverage",
      "phase": "02",
      "date": "2026-02-17"
    },
    {
      "question": "How should custom field types be rendered?",
      "answer": "Type-aware via metadata (select->value, user->displayName, date->formatted, list->comma-join). Generic fallback via value shape inspection. All in ## Custom Fields body section.",
      "area": "custom-field-rendering",
      "phase": "02",
      "date": "2026-02-17"
    }
  ],
  "inferred": [
    {
      "id": "REQ-06",
      "text": "Full standard field coverage with complete schema — all fields always present in output",
      "priority": "Must-have",
      "source": "Discussion: empty-field-handling"
    },
    {
      "id": "REQ-07",
      "text": "Custom field rendering with cached metadata, TOML config, and CLI overrides",
      "priority": "Must-have",
      "source": "Discussion: custom-field-discovery, custom-field-selection, custom-field-rendering"
    },
    {
      "id": "REQ-08",
      "text": "Complete ADF support — all node types with best-effort Markdown rendering, no HTML",
      "priority": "Must-have",
      "source": "Discussion: adf-coverage"
    }
  ],
  "deferred": []
}
