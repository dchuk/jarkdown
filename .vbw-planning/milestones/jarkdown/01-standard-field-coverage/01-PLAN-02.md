---
phase: "01"
plan: "02"
title: "Linked Issues + Subtasks Body Sections"
wave: 1
depends_on: []
skills_used:
  - python-testing-patterns
must_haves:
  - "`_compose_linked_issues_section()` method exists on MarkdownConverter class"
  - "`_compose_subtasks_section()` method exists on MarkdownConverter class"
  - "Linked issues grouped by directional label using `### Label` subheadings (title-cased)"
  - "Each link: `- [KEY](https://domain/browse/KEY): Summary (Status)`"
  - "Subtasks: `- [KEY](https://domain/browse/KEY): Summary (Status) — Type`"
  - "Empty linked issues returns section with 'None' body"
  - "Empty subtasks returns section with 'None' body"
  - "`pytest tests/test_sections_links_subtasks.py` passes"
---

## Objective

Add `_compose_linked_issues_section()` and `_compose_subtasks_section()` methods to MarkdownConverter for rendering issue links and subtasks as markdown body sections.

## Context

Read these files before starting:
- `@src/jarkdown/markdown_converter.py` — add new methods AFTER `replace_attachment_links()` method. Do NOT modify any existing methods. The insertion point is after the `replace_attachment_links` method ends and before `_parse_adf_to_markdown` begins.
- `@.vbw-planning/phases/01-standard-field-coverage/01-CONTEXT.md` — binding rendering decisions
- `@.vbw-planning/phases/01-standard-field-coverage/01-RESEARCH.md` — API field structures

Key API shapes (from research):
- `issuelinks`: Array where each entry has exactly ONE of `inwardIssue` or `outwardIssue` (never both). `type.inward` / `type.outward` give directional labels.
- `subtasks`: Array with `key`, `fields.summary`, `fields.status.name`, `fields.issuetype.name`.

IMPORTANT — Merge safety: This plan runs in parallel with Plans 01 and 03 (same wave). Plan 01 modifies `_generate_metadata_dict()` (much later in the file). Plan 03 inserts methods after `_parse_adf_to_markdown()`. Your insertion point (after `replace_attachment_links`) is well-separated from both. Create test files that do NOT exist yet (unique filenames).

## Tasks

### Task 1: Create test fixtures

Create `tests/data/issue_with_links.json`:
- `key`: `"LINK-100"`, basic fields (summary, issuetype, status, reporter, created, updated)
- `issuelinks` array with 3 entries:
  1. Outward link: type `{"name": "Blocks", "inward": "is blocked by", "outward": "blocks"}`, `outwardIssue` with key `"LINK-200"`, summary `"Blocked Issue"`, status `"To Do"`
  2. Inward link: same Blocks type, `inwardIssue` with key `"LINK-50"`, summary `"Blocking Issue"`, status `"In Progress"`
  3. Outward link: type `{"name": "Relates", "inward": "relates to", "outward": "relates to"}`, `outwardIssue` with key `"LINK-300"`, summary `"Related Issue"`, status `"Done"`
- `renderedFields.description`: simple HTML

Create `tests/data/issue_with_subtasks.json`:
- `key`: `"SUB-100"`, basic fields
- `subtasks` array with 2 entries:
  1. key `"SUB-101"`, summary `"Write unit tests"`, status `"To Do"`, issuetype `"Sub-task"`
  2. key `"SUB-102"`, summary `"Update documentation"`, status `"Done"`, issuetype `"Sub-task"`
- `renderedFields.description`: simple HTML

Commit: `test(phase-01): add linked issues and subtasks fixtures`

### Task 2: Implement _compose_linked_issues_section

Add method to MarkdownConverter AFTER `replace_attachment_links()` method (before `_parse_adf_to_markdown`):

```python
def _compose_linked_issues_section(self, issue_data):
    """Compose the linked issues section of the markdown.

    Args:
        issue_data: Raw issue data from Jira API

    Returns:
        list: Lines of markdown content for linked issues section
    """
```

Logic:
1. Start with `["## Linked Issues", ""]`
2. Extract `fields.issuelinks` (default to `[]`)
3. If empty list: append `"None"`, add trailing `""`, return lines
4. Group links by directional label:
   - If entry has `inwardIssue` → label = `type["inward"]`, issue = entry's `inwardIssue`
   - If entry has `outwardIssue` → label = `type["outward"]`, issue = entry's `outwardIssue`
   - Title-case the label using `.title()` (e.g., "is blocked by" → "Is Blocked By")
5. Use a dict (or `collections.defaultdict`) keyed by title-cased label to group links
6. For each group (in insertion order):
   - Append `### {Label}` heading and blank line
   - For each link: `- [{key}]({self.base_url}/browse/{key}): {summary} ({status_name})`
7. Append trailing `""`
8. Return lines

Commit: `feat(phase-01): add linked issues section renderer`

### Task 3: Implement _compose_subtasks_section

Add method to MarkdownConverter immediately after `_compose_linked_issues_section()`:

```python
def _compose_subtasks_section(self, issue_data):
    """Compose the subtasks section of the markdown.

    Args:
        issue_data: Raw issue data from Jira API

    Returns:
        list: Lines of markdown content for subtasks section
    """
```

Logic:
1. Start with `["## Subtasks", ""]`
2. Extract `fields.subtasks` (default to `[]`)
3. If empty list: append `"None"`, add trailing `""`, return lines
4. For each subtask:
   - `key = subtask["key"]`
   - `summary = subtask["fields"]["summary"]`
   - `status = subtask["fields"]["status"]["name"]`
   - `issue_type = subtask["fields"]["issuetype"]["name"]`
   - Append: `- [{key}]({self.base_url}/browse/{key}): {summary} ({status}) — {issue_type}`
5. Append trailing `""`
6. Return lines

Commit: `feat(phase-01): add subtasks section renderer`

### Task 4: Write tests

Create `tests/test_sections_links_subtasks.py` with its own fixtures:

```python
@pytest.fixture
def converter():
    return MarkdownConverter("https://example.atlassian.net", "example.atlassian.net")
```

**TestLinkedIssuesSection** class:
- `test_linked_issues_with_data`: Load `issue_with_links.json`, call `converter._compose_linked_issues_section(data)`, join result, verify:
  - Contains `## Linked Issues`
  - Contains `### Blocks` group heading with `[LINK-200](https://example.atlassian.net/browse/LINK-200): Blocked Issue (To Do)`
  - Contains `### Is Blocked By` group heading with `[LINK-50](https://example.atlassian.net/browse/LINK-50): Blocking Issue (In Progress)`
  - Contains `### Relates To` group heading with `[LINK-300](https://example.atlassian.net/browse/LINK-300): Related Issue (Done)`
- `test_linked_issues_empty`: Issue with `"issuelinks": []` → output contains "None"
- `test_linked_issues_missing`: Issue with no `issuelinks` key at all → output contains "None"

**TestSubtasksSection** class:
- `test_subtasks_with_data`: Load `issue_with_subtasks.json`, verify:
  - Contains `## Subtasks`
  - Contains `[SUB-101](https://example.atlassian.net/browse/SUB-101): Write unit tests (To Do) — Sub-task`
  - Contains `[SUB-102](https://example.atlassian.net/browse/SUB-102): Update documentation (Done) — Sub-task`
- `test_subtasks_empty`: Issue with `"subtasks": []` → "None"
- `test_subtasks_missing`: Issue with no `subtasks` key → "None"

Commit: `test(phase-01): add linked issues and subtasks section tests`

## Verification

```bash
pytest tests/test_sections_links_subtasks.py -v
pytest tests/test_components.py -v  # existing tests unchanged
```

## Success Criteria

- Both methods exist and are callable on MarkdownConverter
- Linked issues correctly grouped by title-cased directional label
- Each link includes Jira browse URL, summary, and status
- Subtasks rendered as flat bullet list with key, summary, status, and type
- Empty/missing fields produce "None" sections
- All tests pass
