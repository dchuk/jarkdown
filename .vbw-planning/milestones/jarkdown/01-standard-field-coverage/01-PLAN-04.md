---
phase: "01"
plan: "04"
title: "Integration Wiring + Section Ordering"
wave: 2
depends_on: ["01", "02", "03"]
skills_used:
  - python-testing-patterns
must_haves:
  - "`compose_markdown()` calls all 4 new section methods: `_compose_environment_section`, `_compose_linked_issues_section`, `_compose_subtasks_section`, `_compose_worklogs_section`"
  - "Body section order: Description → Environment → Linked Issues → Subtasks → Worklogs → Comments → Attachments"
  - "All new sections always present in output (show 'None' for empty data)"
  - "Comments and Attachments sections retain existing conditional behavior"
  - "Comprehensive integration fixture exists at `tests/data/issue_full_fields.json`"
  - "`pytest tests/` passes with 0 failures"
---

## Objective

Wire all new section methods into `compose_markdown()` with correct section ordering, create a comprehensive integration fixture, and verify the complete end-to-end output.

## Context

Read these files before starting:
- `@src/jarkdown/markdown_converter.py` — modify ONLY `compose_markdown()` method. After Plans 01-03, the file contains new methods that are not yet called from `compose_markdown()`.
- `@tests/test_components.py` — existing tests must still pass after wiring
- `@.vbw-planning/phases/01-standard-field-coverage/01-CONTEXT.md` — section ordering decision

After Plans 01-03, these methods exist on MarkdownConverter but are NOT yet called from `compose_markdown()`:
- `_compose_environment_section(issue_data)` → returns list of markdown lines
- `_compose_linked_issues_section(issue_data)` → returns list of markdown lines
- `_compose_subtasks_section(issue_data)` → returns list of markdown lines
- `_compose_worklogs_section(issue_data)` → returns list of markdown lines

Also, `_generate_metadata_dict()` now returns all 29 frontmatter fields with always-present schema.

## Tasks

### Task 1: Create comprehensive integration fixture

Create `tests/data/issue_full_fields.json` with ALL fields populated:

**Standard existing fields:**
- key, summary, issuetype (with name), status (with name AND statusCategory), priority, resolution (with name), assignee, reporter, creator, labels (non-empty), components (non-empty), parent (with key + summary), versions, fixVersions, created, updated, resolutiondate

**Phase 1 new fields:**
- `project`: `{"id": "10000", "key": "FULL", "name": "Full Fields Project"}`
- `duedate`: `"2025-06-15"`
- `timetracking`: `{"originalEstimate": "2d", "timeSpent": "1d 2h", "remainingEstimate": "6h", "originalEstimateSeconds": 57600, "timeSpentSeconds": 36000, "remainingEstimateSeconds": 21600}`
- `votes`: `{"votes": 7, "hasVoted": false}`
- `watches`: `{"watchCount": 4, "isWatching": true}`
- `progress`: `{"progress": 36000, "total": 57600, "percent": 62}`
- `aggregateprogress`: `{"progress": 50000, "total": 80000, "percent": 62}`

**Body section data:**
- `renderedFields.description`: HTML with some formatting
- `renderedFields.environment`: `"<p>Production — Ubuntu 22.04</p>"`
- `issuelinks`: 2+ links with different types/directions
- `subtasks`: 2+ entries with different statuses
- `worklog`: 2+ entries with ADF comments, `total` matching count
- `comment.comments`: 1+ comment entry with renderedBody
- `attachment`: 1+ attachment entry

This fixture must exercise ALL code paths for a fully populated issue.

Commit: `test(phase-01): add comprehensive integration fixture`

### Task 2: Wire new sections into compose_markdown

Modify `compose_markdown()` to insert new section calls in the correct order. The current body order is: Description → Comments → Attachments. Change it to:

1. Frontmatter (YAML) — existing, no change
2. Title — existing, no change
3. Description — existing, no change
4. **Environment** ← NEW — insert after description block
5. **Linked Issues** ← NEW
6. **Subtasks** ← NEW
7. **Worklogs** ← NEW
8. Comments — existing, keep as-is
9. Attachments — existing, keep as-is

After the description section (after `lines.append("")` that follows description content), add:

```python
# Environment section (always present)
lines.extend(self._compose_environment_section(issue_data))

# Linked Issues section (always present)
lines.extend(self._compose_linked_issues_section(issue_data))

# Subtasks section (always present)
lines.extend(self._compose_subtasks_section(issue_data))

# Worklogs section (always present)
lines.extend(self._compose_worklogs_section(issue_data))
```

These go BEFORE the existing comments section call (`comment_lines = self._compose_comments_section(...)`).

The new sections are "always present" — they always emit their heading and content (or "None"). The existing Comments and Attachments sections retain their current conditional behavior.

Commit: `feat(phase-01): wire new sections into compose_markdown`

### Task 3: Write integration tests

Create `tests/test_integration_standard_fields.py` with its own fixtures:

**TestFullFieldsIntegration** class using `issue_full_fields.json`:
- `test_all_sections_present`: Verify output contains: `## Description`, `## Environment`, `## Linked Issues`, `## Subtasks`, `## Worklogs`, `## Comments`, `## Attachments`
- `test_section_ordering`: Find the index of each `## ` heading in the output string, verify they appear in ascending order: Description < Environment < Linked Issues < Subtasks < Worklogs < Comments < Attachments
- `test_frontmatter_complete`: Parse YAML frontmatter from output, verify all 29 keys present with non-null values (since the full fixture populates everything)
- `test_linked_issues_in_output`: Verify link formatting with directional labels and Jira browse URLs
- `test_subtasks_in_output`: Verify subtask bullet list format with key, summary, status, type
- `test_worklogs_in_output`: Verify table headers and data rows
- `test_environment_in_output`: Verify environment content rendered

**TestEmptyFieldsIntegration** class using inline minimal issue data (no Phase 1 fields):
- `test_empty_new_sections_show_none`: Verify output contains `## Environment` with "None", `## Linked Issues` with "None", `## Subtasks` with "None", `## Worklogs` with "None"
- `test_comments_still_conditional`: Verify `## Comments` does NOT appear when `comment.comments` is empty list
- `test_attachments_still_conditional`: Verify `## Attachments` does NOT appear when no attachments passed

Commit: `test(phase-01): add integration tests for standard field coverage`

### Task 4: Verify all existing tests pass

Run full test suite:
```bash
pytest tests/ -v
```

If any existing tests fail due to wiring changes, fix them. Common potential issues:
- New sections appearing between Description and Comments may affect tests that check for string patterns spanning both — but existing tests only check for presence of individual strings, not relative positions
- Frontmatter now includes more fields — existing tests check specific key values, not dict equality

If adjustments are needed, they should be minimal (e.g., adjusting a test that assumed no content between Description and Comments).

Commit: `fix(phase-01): adjust existing tests for new section ordering` (only if needed — skip this commit if all tests pass as-is)

## Verification

```bash
pytest tests/ -v  # ALL tests pass — 0 failures
```

Manual verification — print complete output for the full fixture:
```bash
python -c "
import json
from jarkdown.markdown_converter import MarkdownConverter
mc = MarkdownConverter('https://example.atlassian.net', 'example.atlassian.net')
with open('tests/data/issue_full_fields.json') as f:
    data = json.load(f)
print(mc.compose_markdown(data, []))
"
```

Visually verify:
- YAML frontmatter has all 29 fields
- Body sections appear in correct order
- Each section has proper content
- Empty sections would show "None" (test with minimal data)

## Success Criteria

- All 4 new section methods called from compose_markdown
- Section order matches spec exactly
- New sections always present (even with empty data)
- Existing Comments/Attachments behavior unchanged
- Full test suite passes with 0 failures
- Complete output is valid, readable markdown
