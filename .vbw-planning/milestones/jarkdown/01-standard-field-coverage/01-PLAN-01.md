---
phase: "01"
plan: "01"
title: "Frontmatter Field Extensions"
wave: 1
depends_on: []
skills_used:
  - python-testing-patterns
must_haves:
  - "`_generate_metadata_dict()` returns all 29 frontmatter fields including new: project, project_key, status_category, duedate, votes, watches, original_estimate, time_spent, remaining_estimate, progress, aggregate_progress"
  - "All fields always present even when source data is null — YAML `null` for missing scalars, `[]` for missing lists, `0` for zero counts"
  - "Field ordering: key, summary, type, status, status_category, priority, resolution, project, project_key, assignee, reporter, creator, labels, components, parent_key, parent_summary, affects_versions, fix_versions, created_at, updated_at, resolved_at, duedate, original_estimate, time_spent, remaining_estimate, progress, aggregate_progress, votes, watches"
  - "Time tracking uses human-readable strings from API (e.g. '1d 2h'), null when absent"
  - "`pytest tests/test_frontmatter_fields.py` passes with both populated and empty field tests"
---

## Objective

Extend `_generate_metadata_dict()` in MarkdownConverter to include all standard Jira fields as frontmatter, and implement an "always present" schema where every field appears in output regardless of whether it has a value.

## Context

Read these files before starting:
- `@src/jarkdown/markdown_converter.py` — modify ONLY `_generate_metadata_dict()` method. Do NOT touch any other method in this file.
- `@tests/test_components.py` — understand existing test patterns and fixtures
- `@tests/data/issue_with_attachments.json` — existing fixture format reference
- `@.vbw-planning/phases/01-standard-field-coverage/01-CONTEXT.md` — binding decisions on field handling
- `@.vbw-planning/phases/01-standard-field-coverage/01-RESEARCH.md` — API field structures

Key API field shapes (from research):
- `project`: `{"key": "EX", "name": "Example Project"}`
- `status.statusCategory`: `{"name": "In Progress"}`
- `duedate`: `"YYYY-MM-DD"` string or `null`
- `timetracking`: `{"originalEstimate": "1d 2h", "timeSpent": "6h", "remainingEstimate": "3h 25m"}` or `null` entirely
- `votes`: `{"votes": 5}` — integer count
- `watches`: `{"watchCount": 3}` — integer count
- `progress`: `{"percent": 60}` — integer or `{"progress": 0, "total": 0, "percent": 0}`
- `aggregateprogress`: same shape as progress

## Tasks

### Task 1: Create frontmatter test fixture

Create `tests/data/issue_standard_fields.json` — a Jira API response fixture with ALL standard fields populated. Must include:
- All existing fields (summary, issuetype, status with statusCategory nested, priority, resolution, assignee, reporter, creator, labels, components, parent, versions, fixVersions, created, updated, resolutiondate, attachment)
- New fields: `project` (with key + name), `duedate` (YYYY-MM-DD string), `timetracking` (with originalEstimate, timeSpent, remainingEstimate as human strings + seconds variants), `votes` (with votes count), `watches` (with watchCount), `progress` (with percent), `aggregateprogress` (with percent)
- Include `renderedFields.description` with simple HTML

Example key/summary: `"PROJ-100"` / `"Standard Fields Test Issue"`.

Commit: `test(phase-01): add frontmatter standard fields fixture`

### Task 2: Refactor _generate_metadata_dict to always-present schema

Modify `_generate_metadata_dict()`:
1. Remove the null-filtering dict comprehension at the end of the method (the `return {k: v for k, v in ...}` block that filters None and empty lists)
2. Make ALL existing fields unconditional — replace every `if fields.get("x"):` guard with direct assignment using `(fields.get("x") or {}).get("name")` pattern
3. Always set list fields unconditionally: `metadata["labels"] = fields.get("labels", [])` etc.
4. Return `metadata` directly (no filtering)
5. Preserve field insertion order (Python dict order = YAML output order via `sort_keys=False`)

After this change, the method returns ALL fields including `None` values and empty lists.

Verify: existing tests in `tests/test_components.py` still pass (`pytest tests/test_components.py`).

Commit: `refactor(phase-01): always-present frontmatter schema`

### Task 3: Add new frontmatter fields

Add these fields to `_generate_metadata_dict()` at the correct position in the dict (maintaining the ordering spec from must_haves):

After `status` field:
- `status_category`: `(fields.get("status") or {}).get("statusCategory", {}).get("name")`

After `resolution` field:
- `project`: `(fields.get("project") or {}).get("name")`
- `project_key`: `(fields.get("project") or {}).get("key")`

After `resolved_at` field:
- `duedate`: `fields.get("duedate")` — already YYYY-MM-DD string or null

After `duedate`:
- `original_estimate`: `(fields.get("timetracking") or {}).get("originalEstimate")` — human string or null
- `time_spent`: `(fields.get("timetracking") or {}).get("timeSpent")`
- `remaining_estimate`: `(fields.get("timetracking") or {}).get("remainingEstimate")`

After time tracking:
- `progress`: `(fields.get("progress") or {}).get("percent", 0)`
- `aggregate_progress`: `(fields.get("aggregateprogress") or {}).get("percent", 0)`

After progress:
- `votes`: `(fields.get("votes") or {}).get("votes", 0)`
- `watches`: `(fields.get("watches") or {}).get("watchCount", 0)`

Note: votes, watches, progress, aggregate_progress default to `0` (integer, not null) since they always have integer values.

Commit: `feat(phase-01): add standard fields to frontmatter`

### Task 4: Write frontmatter field tests

Create `tests/test_frontmatter_fields.py` with its own fixtures:

```python
@pytest.fixture
def converter():
    return MarkdownConverter("https://example.atlassian.net", "example.atlassian.net")

@pytest.fixture
def issue_standard_fields():
    with open("tests/data/issue_standard_fields.json") as f:
        return json.load(f)
```

**TestFrontmatterPopulated** class — uses `issue_standard_fields` fixture:
- Test all new fields have expected non-null values: project, project_key, status_category, duedate, votes, watches, original_estimate, time_spent, remaining_estimate, progress, aggregate_progress
- Verify values match the fixture data

**TestFrontmatterEmpty** class — uses inline minimal issue data with all new fields null/absent:
- Test with `timetracking: null` (entire object null) — doesn't crash, yields null estimates
- Test with no `project`, `votes`, `watches`, `progress`, `aggregateprogress` keys at all
- Verify: `project: None`, `project_key: None`, `status_category: None`, `duedate: None`
- Verify: `original_estimate: None`, `time_spent: None`, `remaining_estimate: None`
- Verify: `progress == 0`, `aggregate_progress == 0`, `votes == 0`, `watches == 0`

**TestFrontmatterFieldOrdering** class:
- Call `_generate_metadata_dict()` with populated data
- Get `list(metadata.keys())` and verify the order matches the spec exactly (all 29 keys in order)

Commit: `test(phase-01): add frontmatter field tests`

## Verification

```bash
pytest tests/test_frontmatter_fields.py -v
pytest tests/test_components.py -v  # existing tests must still pass
```

## Success Criteria

- All 29 frontmatter fields present in YAML output for any input
- Null fields render as YAML `null`
- Zero-value integer fields render as `0`
- Time tracking fields show human-readable strings from API
- Field ordering matches specification
- All tests pass (new and existing)
