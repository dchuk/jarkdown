---
phase: "04"
plan: "01"
title: "Async API Client & Attachment Handler Migration"
wave: 1
depends_on: []
skills_used:
  - python-testing-patterns
must_haves:
  - "JiraApiClient class is fully async (aiohttp); class name unchanged to preserve all existing imports"
  - "JiraApiClient has `__aenter__`/`__aexit__` managing single aiohttp.ClientSession with TCPConnector(limit_per_host=5) and graceful SSL shutdown via `await asyncio.sleep(0.250)`"
  - "fetch_issue(), fetch_fields(), download_attachment_stream() are all async coroutines; HTTP errors map 401→AuthenticationError, 404→IssueNotFoundError, others→JiraApiError"
  - "AttachmentHandler.download_attachment() and download_all_attachments() are async; chunk streaming uses `await response.content.read(8192)` (aiohttp pattern)"
  - "aiohttp>=3.9.0 added to [project.dependencies]; aioresponses>=0.7.6 and pytest-asyncio>=0.23.0 added to [project.optional-dependencies] dev"
  - "`pytest tests/test_components.py` passes with 0 failures after updating async tests with @pytest.mark.asyncio"
---

## Objective

Replace `requests`-based JiraApiClient and AttachmentHandler with fully async `aiohttp` implementations. The class names stay the same to avoid import changes in all other files. This is the async foundation that all bulk export logic in wave 2 depends on.

## Context

Read these files before starting:
- `@src/jarkdown/jira_api_client.py` — full rewrite target (141 lines, requests.Session)
- `@src/jarkdown/attachment_handler.py` — full rewrite target (118 lines, iter_content)
- `@src/jarkdown/exceptions.py` — exception hierarchy; do NOT change this file
- `@pyproject.toml` — add aiohttp + test deps here
- `@tests/test_components.py` — update for async; existing mock patterns will change
- `@.vbw-planning/phases/04-bulk-export-jql/04-CONTEXT.md` — design decisions (async, session lifecycle, TCPConnector)
- `@.vbw-planning/phases/04-bulk-export-jql/04-RESEARCH.md` — aiohttp patterns, risks, SSL cleanup

Key constraints from research:
- TCPConnector `limit_per_host` MUST be >= semaphore limit (default 3) — set to 5 to be safe
- Add explicit `Accept: application/json` header — aiohttp JSON validation is strict
- `raise_for_status()` does NOT auto-raise in aiohttp; must call explicitly before `.json()`
- Error type: `aiohttp.ClientError` (not `requests.exceptions.RequestException`)
- Chunk streaming: `async for chunk in response.content.iter_chunked(8192)` or `await response.content.read(8192)` in a loop

Merge safety: This plan owns `jira_api_client.py`, `attachment_handler.py`, `pyproject.toml`, `tests/test_components.py`. Plan 02 owns `jarkdown.py` and `tests/test_cli.py`. Plan 03 creates new files only. No overlaps.

## Tasks

### Task 1: Add aiohttp dependencies to pyproject.toml

**Files:** `pyproject.toml`

Add to `[project.dependencies]`:
- `aiohttp>=3.9.0`

Add to `[project.optional-dependencies]` dev section:
- `pytest-asyncio>=0.23.0`
- `aioresponses>=0.7.6`

Also add `asyncio_mode = "auto"` to `[tool.pytest.ini_options]` so all async tests run without explicit `@pytest.mark.asyncio` decorators (cleaner). Set it as:
```toml
asyncio_mode = "auto"
```

Run `uv sync` mentally to confirm no version conflicts — no action needed in file.

**Tests:** None — dependency change only.

**Commit:** `chore(phase-04): add aiohttp and async test dependencies`

---

### Task 2: Rewrite JiraApiClient as async aiohttp client

**Files:** `src/jarkdown/jira_api_client.py`

Full rewrite keeping class name `JiraApiClient`. Key design:

```python
import asyncio
import aiohttp
from .exceptions import JiraApiError, AuthenticationError, IssueNotFoundError

class JiraApiClient:
    def __init__(self, domain, email, api_token):
        self.domain = domain
        self.email = email
        self.api_token = api_token
        self.base_url = f"https://{domain}"
        self.api_base = f"{self.base_url}/rest/api/3"
        self.session = None  # set in __aenter__

    async def __aenter__(self):
        connector = aiohttp.TCPConnector(limit_per_host=5)
        auth = aiohttp.BasicAuth(self.email, self.api_token)
        timeout = aiohttp.ClientTimeout(total=30)
        self.session = aiohttp.ClientSession(
            connector=connector,
            auth=auth,
            timeout=timeout,
            headers={"Accept": "application/json", "Content-Type": "application/json"},
        )
        return self

    async def __aexit__(self, *args):
        await self.session.close()
        await asyncio.sleep(0.250)  # SSL cleanup per research
```

Implement `fetch_issue(issue_key)` as async:
- URL: `{api_base}/issue/{issue_key}?fields=*all&expand=renderedFields`
- Catch `aiohttp.ClientResponseError`: 401→AuthenticationError, 404→IssueNotFoundError, other→JiraApiError
- Catch `aiohttp.ClientError` → JiraApiError
- Return `await response.json()`

Implement `fetch_fields()` as async:
- URL: `{api_base}/field`
- Same error mapping as fetch_issue

Implement `get_attachment_content_url(attachment)` — unchanged (no I/O, pure accessor):
- Return `attachment.get("content", "")`

**Tests:** Existing tests will break; fixed in Task 5.

**Commit:** `feat(phase-04): rewrite JiraApiClient as async aiohttp client`

---

### Task 3: Add async download_attachment_stream to JiraApiClient

**Files:** `src/jarkdown/jira_api_client.py`

Add `download_attachment_stream(content_url)` as async method:

```python
async def download_attachment_stream(self, content_url):
    """Stream download an attachment.

    Args:
        content_url: The URL to download the attachment from

    Returns:
        aiohttp.ClientResponse: Active response object for streaming

    Raises:
        JiraApiError: If download fails
    """
    try:
        response = await self.session.get(content_url)
        response.raise_for_status()
        return response
    except aiohttp.ClientResponseError as e:
        raise JiraApiError(f"Error downloading attachment: HTTP {e.status}")
    except aiohttp.ClientError as e:
        raise JiraApiError(f"Error downloading attachment: {e}")
```

Note: The caller (AttachmentHandler) is responsible for reading response chunks and closing the response. The session must remain open while reading.

**Tests:** Covered in Task 5.

**Commit:** `feat(phase-04): add async download_attachment_stream to JiraApiClient`

---

### Task 4: Rewrite AttachmentHandler as async

**Files:** `src/jarkdown/attachment_handler.py`

Full rewrite with async methods. Key changes:

```python
import asyncio
from pathlib import Path
from .exceptions import AttachmentDownloadError

class AttachmentHandler:
    def __init__(self, api_client):
        self.api_client = api_client
        self.logger = logging.getLogger(__name__)

    async def download_attachment(self, attachment, output_dir):
        """Download a single attachment asynchronously."""
        filename = attachment["filename"]
        content_url = attachment["content"]
        mime_type = attachment.get("mimeType", "")
        size = attachment.get("size", 0)
        file_path = output_dir / filename

        # Handle filename conflicts (sync — just stat checks)
        counter = 1
        original_path = file_path
        while file_path.exists():
            stem = original_path.stem
            suffix = original_path.suffix
            file_path = original_path.parent / f"{stem}_{counter}{suffix}"
            counter += 1

        try:
            response = await self.api_client.download_attachment_stream(content_url)
            # Use asyncio.to_thread for file writes to avoid blocking event loop
            async def _write():
                with open(file_path, "wb") as f:
                    async for chunk in response.content.iter_chunked(8192):
                        if chunk:
                            f.write(chunk)
            await asyncio.to_thread(_write) if False else await _write_direct()
            # Simpler: use response.content.iter_chunked directly with sync write
            # since we're in async context, blocking writes are short per-chunk
```

Actually, implement it cleanly:
```python
        async with self.api_client.session.get(content_url) as response:
            response.raise_for_status()
            await asyncio.to_thread(_write_file, file_path, response_chunks)
```

Simplest correct implementation pattern:
```python
async def download_attachment(self, attachment, output_dir):
    filename = attachment["filename"]
    content_url = attachment["content"]
    # ... filename conflict resolution (sync, just stat checks) ...
    response = await self.api_client.download_attachment_stream(content_url)
    # Buffer entire attachment then write via thread to avoid blocking event loop
    data = await response.read()
    await asyncio.to_thread(file_path.write_bytes, data)
    return {"attachment_id": ..., "filename": file_path.name, ...}
```
Note: buffering is acceptable for typical Jira attachments (documents, images, logs).

Implement `download_all_attachments(attachments, output_dir)` as async — iterate sequentially (attachment downloads are NOT parallelized by default; the bulk semaphore controls overall concurrency).

Keep `_format_size()` as synchronous helper (no I/O).

**Tests:** Covered in Task 5.

**Commit:** `feat(phase-04): rewrite AttachmentHandler as async`

---

### Task 5: Update tests/test_components.py for async

**Files:** `tests/test_components.py`

Update all JiraApiClient and AttachmentHandler tests to be async:

1. Replace `requests_mock` fixtures with `aioresponses` library:
```python
from aioresponses import aioresponses

@pytest.fixture
def mock_api():
    with aioresponses() as m:
        yield m
```

2. All test methods that call async client methods become `async def test_*(...)` — with `asyncio_mode = "auto"` in pytest config, no decorator needed.

3. JiraApiClient must be used as async context manager in tests:
```python
async def test_fetch_issue(mock_api):
    mock_api.get("https://example.atlassian.net/rest/api/3/issue/TEST-1", ...)
    async with JiraApiClient("example.atlassian.net", "u@e.com", "tok") as client:
        result = await client.fetch_issue("TEST-1")
    assert result["key"] == "TEST-1"
```

4. Mock 401 → verify AuthenticationError raised
5. Mock 404 → verify IssueNotFoundError raised
6. Mock download endpoint → verify AttachmentHandler saves file

All existing test SCENARIOS must be preserved (same test names and assertions); only the async mechanics change.

Run `pytest tests/test_components.py -v` — must pass 0 failures.

**Tests:** This task IS the test update.

**Commit:** `test(phase-04): update test_components.py for async aiohttp client`

## Verification

```bash
pytest tests/test_components.py -v
pytest tests/ -v --ignore=tests/test_bulk_exporter.py  # all pre-existing tests pass
uv run python -c "from jarkdown.jira_api_client import JiraApiClient; import inspect; print(inspect.iscoroutinefunction(JiraApiClient.fetch_issue))"  # outputs True
```

## Success Criteria

- JiraApiClient is fully async with `__aenter__`/`__aexit__` session lifecycle
- All three main methods (fetch_issue, fetch_fields, download_attachment_stream) are coroutines
- Error mapping preserved: 401→AuthenticationError, 404→IssueNotFoundError
- AttachmentHandler methods are coroutines; writes use asyncio.to_thread for file I/O
- TCPConnector limit_per_host=5, graceful SSL shutdown after session close
- All test_components.py tests pass using aioresponses mocks
- aiohttp, pytest-asyncio, aioresponses in pyproject.toml
