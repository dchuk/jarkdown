---
phase: "04"
plan: "03"
title: "Retry & Rate Limiting Infrastructure"
wave: 1
depends_on: []
skills_used:
  - python-testing-patterns
must_haves:
  - "`src/jarkdown/retry.py` exists with `RetryConfig` dataclass and `retry_with_backoff()` async function"
  - "RetryConfig defaults: max_retries=3, base_delay=1.0, max_delay=60.0, jitter=True"
  - "`parse_retry_after(header_value)` correctly parses both integer seconds and HTTP-date formats"
  - "`retry_with_backoff()` raises the final exception after max_retries exhausted (does not swallow errors)"
  - "Exponential delay formula: `min(base_delay * 2**attempt, max_delay)` with optional jitter (`random.uniform(0, delay)` added)"
  - "`pytest tests/test_retry.py` passes with ≥12 test cases covering all branches"
---

## Objective

Create a standalone retry and rate-limiting helper module (`src/jarkdown/retry.py`) that the wave-2 bulk export engine (Plan 04) will use to handle Jira 429 responses with exponential backoff. This module has zero dependencies on other jarkdown modules — it's pure Python and can be developed and tested in parallel with the async migration (Plan 01) and CLI restructuring (Plan 02).

## Context

Read these files before starting:
- `@.vbw-planning/phases/04-bulk-export-jql/04-CONTEXT.md` — retry policy decisions (exponential backoff, Retry-After, continue-and-report)
- `@.vbw-planning/phases/04-bulk-export-jql/04-RESEARCH.md` — Jira rate limiting patterns (429, Retry-After header, X-RateLimit-* headers)
- `@src/jarkdown/exceptions.py` — exception hierarchy; do NOT modify

Key decisions from context and research:
- Retry on: 429 (rate limit), 503 (service unavailable), `asyncio.TimeoutError`, `aiohttp.ServerTimeoutError`
- Do NOT retry on: 401, 403, 404 (client errors that won't resolve with retrying)
- Retry-After header format: either integer seconds (`"30"`) or HTTP-date (`"Mon, 17 Feb 2026 12:00:00 GMT"`)
- After max_retries: raise the final exception (caller decides how to handle — bulk engine uses return_exceptions=True)
- The `retry_with_backoff()` function wraps any async callable, not just HTTP calls

Merge safety: This plan creates two NEW files only: `src/jarkdown/retry.py` and `tests/test_retry.py`. Zero overlap with Plans 01 or 02.

## Tasks

### Task 1: Create RetryConfig dataclass

**Files:** `src/jarkdown/retry.py`

Create `src/jarkdown/retry.py` with `RetryConfig`:

```python
"""Retry and rate-limiting utilities for async API calls."""

import asyncio
import random
import time
import logging
from dataclasses import dataclass, field
from email.utils import parsedate_to_datetime
from typing import Tuple, Type

logger = logging.getLogger(__name__)


@dataclass
class RetryConfig:
    """Configuration for retry behavior with exponential backoff.

    Attributes:
        max_retries: Maximum number of retry attempts before raising.
        base_delay: Initial delay in seconds (doubles each attempt).
        max_delay: Cap on delay regardless of backoff calculation.
        jitter: If True, add random jitter to prevent thundering herd.
        retryable_status_codes: HTTP status codes that should trigger retry.
    """
    max_retries: int = 3
    base_delay: float = 1.0
    max_delay: float = 60.0
    jitter: bool = True
    retryable_status_codes: Tuple[int, ...] = (429, 503, 504)
```

Also define module-level constant:
```python
DEFAULT_RETRY = RetryConfig()
```

**Tests:** Covered in Task 4.

**Commit:** `feat(phase-04): add RetryConfig dataclass to retry module`

---

### Task 2: Implement parse_retry_after()

**Files:** `src/jarkdown/retry.py`

Add `parse_retry_after(header_value: str) -> float` function:

```python
def parse_retry_after(header_value: str) -> float:
    """Parse a Retry-After header value into seconds to wait.

    Handles both formats:
    - Integer seconds: "30" → 30.0
    - HTTP-date: "Mon, 17 Feb 2026 12:00:00 GMT" → seconds until that time

    Args:
        header_value: Raw Retry-After header string

    Returns:
        Number of seconds to wait (minimum 0.0, maximum 300.0)
    """
    header_value = header_value.strip()

    # Try integer seconds first
    try:
        seconds = float(header_value)
        return max(0.0, min(seconds, 300.0))
    except ValueError:
        pass

    # Try HTTP-date format
    try:
        retry_time = parsedate_to_datetime(header_value)
        now = datetime.now(tz=timezone.utc)  # add datetime imports at top
        wait = (retry_time - now).total_seconds()
        return max(0.0, min(wait, 300.0))
    except Exception:
        # Cannot parse — return default 5 seconds
        return 5.0
```

Import `from datetime import datetime, timezone` at module top.

**Tests:** Covered in Task 4.

**Commit:** `feat(phase-04): add parse_retry_after helper to retry module`

---

### Task 3: Implement retry_with_backoff()

**Files:** `src/jarkdown/retry.py`

Add the core retry function:

```python
async def retry_with_backoff(
    coro_func,
    *args,
    config: RetryConfig = DEFAULT_RETRY,
    retry_after_header: str = None,
    **kwargs,
):
    """Retry an async callable with exponential backoff.

    Retries on aiohttp.ClientResponseError with retryable status codes,
    asyncio.TimeoutError, and aiohttp.ServerTimeoutError.

    Args:
        coro_func: Async callable to retry.
        *args: Positional arguments to pass to coro_func.
        config: RetryConfig controlling retry behavior.
        retry_after_header: If provided, used for first retry delay.
        **kwargs: Keyword arguments to pass to coro_func.

    Returns:
        Result of coro_func on success.

    Raises:
        The last exception if all retries are exhausted.
    """
    import aiohttp

    last_exc = None
    for attempt in range(config.max_retries + 1):
        try:
            return await coro_func(*args, **kwargs)
        except aiohttp.ClientResponseError as e:
            if e.status not in config.retryable_status_codes:
                raise  # Non-retryable HTTP error (401, 404, etc.)
            last_exc = e
            if attempt == config.max_retries:
                break
            # Use Retry-After if available (only on first attempt and if provided)
            if attempt == 0 and retry_after_header:
                delay = parse_retry_after(retry_after_header)
            else:
                delay = min(config.base_delay * (2 ** attempt), config.max_delay)
                if config.jitter:
                    delay += random.uniform(0, delay * 0.1)
            logger.warning(
                f"Rate limited (attempt {attempt + 1}/{config.max_retries}), "
                f"retrying in {delay:.1f}s..."
            )
            await asyncio.sleep(delay)
        except (asyncio.TimeoutError,) as e:
            last_exc = e
            if attempt == config.max_retries:
                break
            delay = min(config.base_delay * (2 ** attempt), config.max_delay)
            if config.jitter:
                delay += random.uniform(0, delay * 0.1)
            await asyncio.sleep(delay)

    raise last_exc
```

**Tests:** Covered in Task 4.

**Commit:** `feat(phase-04): add retry_with_backoff async function`

---

### Task 4: Write comprehensive tests/test_retry.py

**Files:** `tests/test_retry.py`

Create `tests/test_retry.py` with at least 12 test cases:

```python
import asyncio
import pytest
from unittest.mock import AsyncMock, patch
from datetime import datetime, timezone, timedelta
from jarkdown.retry import RetryConfig, parse_retry_after, retry_with_backoff, DEFAULT_RETRY
```

**TestRetryConfig** class:
- `test_defaults`: Verify max_retries=3, base_delay=1.0, max_delay=60.0, jitter=True
- `test_custom_values`: Create RetryConfig(max_retries=1, base_delay=0.1), verify fields
- `test_retryable_status_codes_include_429`: Assert 429 in DEFAULT_RETRY.retryable_status_codes
- `test_retryable_status_codes_include_503`: Assert 503 in DEFAULT_RETRY.retryable_status_codes

**TestParseRetryAfter** class:
- `test_integer_seconds`: parse_retry_after("30") == 30.0
- `test_zero_seconds`: parse_retry_after("0") == 0.0
- `test_large_value_capped`: parse_retry_after("999") == 300.0 (capped at 300)
- `test_negative_clamped_to_zero`: parse_retry_after("-5") == 0.0
- `test_http_date_future`: Create date 30s in future, verify result ≈ 30.0 (within 2s tolerance)
- `test_http_date_past_clamped`: Create date 30s in past, verify result == 0.0
- `test_unparseable_returns_default`: parse_retry_after("invalid garbage") == 5.0

**TestRetryWithBackoff** class:
- `test_success_on_first_attempt`: Mock that succeeds immediately — called exactly once
- `test_retries_on_429_then_succeeds`: Mock raises 429 twice then returns — called 3 times total
- `test_raises_after_max_retries_exhausted`: Mock always raises 429 — raises ClientResponseError after max_retries+1 attempts
- `test_non_retryable_404_raises_immediately`: Mock raises 404 — NOT retried, raises on first call
- `test_timeout_error_is_retried`: Mock raises asyncio.TimeoutError then succeeds — retried once

Use `AsyncMock` and `pytest.mark.asyncio` (or asyncio_mode=auto). Patch `asyncio.sleep` to avoid actual delays:
```python
@patch("asyncio.sleep", new_callable=AsyncMock)
async def test_retries_on_429_then_succeeds(mock_sleep):
    ...
    assert mock_sleep.call_count == 2  # slept twice between 3 attempts
```

**Commit:** `test(phase-04): add comprehensive retry module tests`

## Verification

```bash
pytest tests/test_retry.py -v
# Verify 12+ test cases pass
pytest tests/test_retry.py -v --tb=short | grep "passed"
```

## Success Criteria

- `retry.py` module importable with `from jarkdown.retry import RetryConfig, retry_with_backoff`
- `RetryConfig` is a dataclass with correct defaults
- `parse_retry_after()` handles integer and HTTP-date formats, clamps to 0-300 range
- `retry_with_backoff()` retries on 429/503/TimeoutError, raises immediately on 401/404
- Exponential backoff: delay doubles each attempt, capped at max_delay
- After max_retries exhausted, raises the last exception (no silent swallowing)
- ≥12 test cases, all passing
- Zero imports from other jarkdown modules (pure Python + aiohttp in retry_with_backoff)
