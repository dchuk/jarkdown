---
phase: "02"
plan: "01"
title: "ADF Parser Extensions"
wave: 1
depends_on: []
skills_used:
  - python-testing-patterns
must_haves:
  - "`_parse_adf_to_markdown()` handles all 12 new ADF node types: table, tableRow, tableHeader, tableCell, panel, expand, rule, emoji, status, date, inlineCard, mediaGroup"
  - "ADF `table` renders as pipe-delimited Markdown table with header separator row"
  - "ADF `panel` renders as blockquote with bold type prefix (e.g., `> **Note:** content`)"
  - "ADF `expand` renders as bold title line followed by indented content"
  - "ADF `rule` renders as `---` horizontal rule"
  - "ADF `emoji` renders as `:shortName:` shortcode text"
  - "ADF `status` renders as bold text (e.g., `**IN PROGRESS**`)"
  - "ADF `date` renders as ISO date string from timestamp"
  - "ADF `inlineCard` renders as `[url](url)` link"
  - "ADF `taskList`/`taskItem` renders as `- [ ]`/`- [x]` checkboxes"
  - "ADF `decisionList`/`decisionItem` renders as blockquoted decision items"
  - "`pytest tests/test_adf_nodes.py` passes with all node types tested"
  - "Existing tests in `tests/test_components.py` still pass"
---

## Objective

Extend `_parse_adf_to_markdown()` in MarkdownConverter to handle all remaining ADF node types per REQ-08. Each node type adds an `elif` branch following the existing pattern. No other methods in the file are modified.

## Context

Read these files before starting:
- `@src/jarkdown/markdown_converter.py` — modify ONLY `_parse_adf_to_markdown()` method (lines 306-442). Do NOT touch any other method.
- `@tests/test_components.py` — existing ADF parsing tests for reference
- `@.vbw-planning/phases/02-custom-fields-adf/02-CONTEXT.md` — binding decisions on ADF rendering
- `@.vbw-planning/phases/02-custom-fields-adf/02-RESEARCH.md` — ADF node specs and nesting rules

Merge safety: This plan runs in parallel with Plans 02 and 03 (same wave). Plan 02 modifies `jira_api_client.py`, `exceptions.py`, `pyproject.toml`. Plan 03 creates new file `config_manager.py`. This plan modifies ONLY `markdown_converter.py` (inside `_parse_adf_to_markdown`) and creates new test files. File sets are disjoint.

ADF node rendering rules (from 02-CONTEXT.md):
- table → Markdown pipe tables
- panel → blockquote with type prefix header
- expand → bold header + content (no HTML)
- emoji → `:shortName:` shortcode
- inlineCard → `[url](url)` link
- taskList/taskItem → `- [ ]`/`- [x]` checkboxes
- decisionList/decisionItem → blockquoted items
- status → bold text
- date → formatted date string from timestamp
- rule → `---` horizontal rule

## Tasks

### Task 1: Add ADF table support

Add `table`, `tableRow`, `tableHeader`, `tableCell` handling to `_parse_adf_to_markdown()` as new `elif` branches BEFORE the existing `else` fallback clause.

Table rendering logic:
1. `table`: Extract `content` (array of tableRow nodes). For each row, parse cells. Build pipe-delimited output. After the first row (or first `tableHeader` row), insert a separator row (`|---|---|...`). Join rows with newlines.
2. `tableRow` / `tableHeader`: Extract `content` (array of tableCell). Return list of cell texts joined by ` | ` with leading/trailing pipes.
3. `tableCell`: Extract `content`, recursively parse children. Flatten multi-line content to single line by replacing newlines with spaces. Strip leading/trailing whitespace.

Implementation detail for `table`:
```python
elif doc_type == "table":
    content = adf_content.get("content", [])
    rows = []
    for i, row_node in enumerate(content):
        cells = row_node.get("content", [])
        cell_texts = []
        for cell in cells:
            cell_content = cell.get("content", [])
            text = " ".join(
                self._parse_adf_to_markdown(node) for node in cell_content
            ).replace("\n", " ").strip()
            cell_texts.append(text)
        rows.append("| " + " | ".join(cell_texts) + " |")
        if i == 0:
            rows.append("| " + " | ".join("---" for _ in cell_texts) + " |")
    return "\n".join(rows)
```

Also add `tableRow`, `tableCell`, `tableHeader` as pass-through branches (they are only called recursively from `table`, but add them for safety):
```python
elif doc_type in ("tableRow", "tableHeader"):
    # Handled inline by table parser
    content = adf_content.get("content", [])
    return " | ".join(
        " ".join(self._parse_adf_to_markdown(n) for n in cell.get("content", [])).replace("\n", " ").strip()
        for cell in content
    )

elif doc_type == "tableCell":
    content = adf_content.get("content", [])
    return " ".join(self._parse_adf_to_markdown(node) for node in content).replace("\n", " ").strip()
```

Create test fixture `tests/data/adf_table.json` — an ADF document with a 3-column, 3-row table (header + 2 data rows).

Commit: `feat(phase-02): add ADF table support`

### Task 2: Add panel, expand, and rule support

Add `elif` branches for `panel`, `expand`, and `rule` to `_parse_adf_to_markdown()`.

**Panel** (attrs has `panelType`: info, warning, note, error, success):
```python
elif doc_type == "panel":
    attrs = adf_content.get("attrs", {})
    panel_type = attrs.get("panelType", "info").capitalize()
    content = adf_content.get("content", [])
    body = "\n".join(self._parse_adf_to_markdown(node) for node in content)
    lines = []
    lines.append(f"> **{panel_type}:**")
    for line in body.split("\n"):
        lines.append(f"> {line}" if line else ">")
    return "\n".join(lines)
```

**Expand** (attrs may have `title`; content is array of blocks):
```python
elif doc_type == "expand":
    attrs = adf_content.get("attrs", {})
    title = attrs.get("title", "Details")
    content = adf_content.get("content", [])
    body = "\n".join(self._parse_adf_to_markdown(node) for node in content)
    lines = [f"**{title}**", ""]
    for line in body.split("\n"):
        lines.append(f"  {line}" if line else "")
    return "\n".join(lines)
```

**Rule** (horizontal divider, no content or attrs):
```python
elif doc_type == "rule":
    return "---"
```

Create test fixture `tests/data/adf_panel_expand_rule.json` — ADF document containing one info panel, one warning panel, one expand block, and one rule.

Commit: `feat(phase-02): add ADF panel, expand, and rule support`

### Task 3: Add inline node support (emoji, status, date, inlineCard)

Add `elif` branches for inline ADF nodes.

**Emoji** (attrs: shortName, id, text):
```python
elif doc_type == "emoji":
    attrs = adf_content.get("attrs", {})
    short_name = attrs.get("shortName", "")
    return short_name if short_name else attrs.get("text", "")
```

**Status** (attrs: text, color, localId, style):
```python
elif doc_type == "status":
    attrs = adf_content.get("attrs", {})
    text = attrs.get("text", "")
    return f"**{text}**"
```

**Date** (attrs: timestamp — milliseconds since epoch):
```python
elif doc_type == "date":
    attrs = adf_content.get("attrs", {})
    timestamp = attrs.get("timestamp", "")
    if timestamp:
        from datetime import datetime, timezone
        try:
            dt = datetime.fromtimestamp(int(timestamp) / 1000, tz=timezone.utc)
            return dt.strftime("%Y-%m-%d")
        except (ValueError, TypeError, OSError):
            return str(timestamp)
    return ""
```

**InlineCard** (attrs: url, data):
```python
elif doc_type == "inlineCard":
    attrs = adf_content.get("attrs", {})
    url = attrs.get("url", "")
    if url:
        return f"[{url}]({url})"
    return ""
```

Create test fixture `tests/data/adf_inline_nodes.json` — ADF doc with paragraphs containing emoji, status, date, and inlineCard nodes.

Commit: `feat(phase-02): add ADF inline node support`

### Task 4: Add taskList, decisionList, and mediaGroup support

**TaskList/TaskItem** (taskItem attrs: `localId`, `state` — "TODO" or "DONE"):
```python
elif doc_type == "taskList":
    content = adf_content.get("content", [])
    items = []
    for item in content:
        items.append(self._parse_adf_to_markdown(item))
    return "\n".join(items)

elif doc_type == "taskItem":
    attrs = adf_content.get("attrs", {})
    state = attrs.get("state", "TODO")
    checkbox = "[x]" if state == "DONE" else "[ ]"
    content = adf_content.get("content", [])
    text = "".join(self._parse_adf_to_markdown(node) for node in content)
    return f"- {checkbox} {text}"
```

**DecisionList/DecisionItem** (decisionItem attrs: localId, state):
```python
elif doc_type == "decisionList":
    content = adf_content.get("content", [])
    items = []
    for item in content:
        items.append(self._parse_adf_to_markdown(item))
    return "\n".join(items)

elif doc_type == "decisionItem":
    attrs = adf_content.get("attrs", {})
    state = attrs.get("state", "DECIDED")
    content = adf_content.get("content", [])
    text = "".join(self._parse_adf_to_markdown(node) for node in content)
    return f"> **Decision:** {text}"
```

**MediaGroup** (gallery container — just render each child media):
```python
elif doc_type == "mediaGroup":
    content = adf_content.get("content", [])
    rendered = [self._parse_adf_to_markdown(node) for node in content if node]
    return "\n".join(filter(None, rendered))
```

Create test fixture `tests/data/adf_task_decision.json` — ADF doc with taskList (mixed TODO/DONE items) and decisionList.

Commit: `feat(phase-02): add ADF task list, decision list, and media group support`

### Task 5: Write comprehensive ADF node tests

Create `tests/test_adf_nodes.py` with fixtures and test classes:

```python
@pytest.fixture
def converter():
    return MarkdownConverter("https://example.atlassian.net", "example.atlassian.net")
```

**TestAdfTable** class:
- `test_basic_table`: 3×3 table renders with pipe delimiters and header separator
- `test_table_with_formatted_content`: Table cells with bold/italic text
- `test_empty_table`: Table with no rows → empty string

**TestAdfPanel** class:
- `test_info_panel`: Panel with `panelType: "info"` → `> **Info:**` prefix
- `test_warning_panel`: Panel with `panelType: "warning"` → `> **Warning:**` prefix
- `test_error_panel`: Panel with `panelType: "error"` → `> **Error:**` prefix
- `test_panel_multiline`: Panel with multiple paragraphs, all prefixed with `>`

**TestAdfExpand** class:
- `test_expand_with_title`: Expand block → bold title + indented content
- `test_expand_default_title`: Expand without title attr → "Details"

**TestAdfRule** class:
- `test_rule`: Rule node → `---`

**TestAdfInlineNodes** class:
- `test_emoji`: Emoji with shortName `:thumbsup:` → `:thumbsup:`
- `test_status`: Status with text "IN PROGRESS" → `**IN PROGRESS**`
- `test_date`: Date with timestamp `1672531200000` (2023-01-01 UTC) → `2023-01-01`
- `test_inline_card`: InlineCard with URL → `[url](url)`

**TestAdfTaskDecision** class:
- `test_task_list_mixed`: TaskList with TODO and DONE items → `- [ ]` and `- [x]`
- `test_decision_list`: DecisionList → `> **Decision:**` items

**TestAdfMediaGroup** class:
- `test_media_group`: MediaGroup with 2 media children → both rendered

Run `pytest tests/test_components.py -v` to confirm existing tests unchanged.

Commit: `test(phase-02): add comprehensive ADF node tests`

## Verification

```bash
pytest tests/test_adf_nodes.py -v
pytest tests/test_components.py -v  # existing tests must still pass
```

## Success Criteria

- All 12 new ADF node types handled in `_parse_adf_to_markdown()`
- Tables render as valid Markdown pipe tables
- Panels render as blockquotes with type-specific prefix
- Expand blocks render as bold title + indented body
- Inline nodes (emoji, status, date, inlineCard) render correctly inline
- Task/decision lists render with appropriate checkbox/blockquote syntax
- All tests pass (new and existing)
