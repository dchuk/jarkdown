---
phase: "02"
plan: "03"
title: "Configuration Manager"
wave: 1
depends_on: []
skills_used:
  - python-testing-patterns
must_haves:
  - "New file `src/jarkdown/config_manager.py` with `ConfigManager` class"
  - "`.jarkdown.toml` config file support with include/exclude field lists"
  - "TOML parsing via `tomllib` (3.11+) with `tomli` fallback (3.8-3.10)"
  - "`ConfigManager.get_field_filter()` returns resolved include/exclude sets"
  - "CLI args override config file: include/exclude CLI params override `.jarkdown.toml`"
  - "Default behavior: include all custom fields with non-null values (no config needed)"
  - "`should_include_field()` is a static method for use by other components"
  - "`pytest tests/test_config_manager.py` passes"
---

## Objective

Create a ConfigManager class that loads field selection preferences from `.jarkdown.toml` config files and merges them with CLI argument overrides. Handles TOML parsing with Python version-appropriate library.

## Context

Read these files before starting:
- `@.vbw-planning/phases/02-custom-fields-adf/02-CONTEXT.md` — config design decisions
- `@.vbw-planning/phases/02-custom-fields-adf/02-RESEARCH.md` — TOML lib compatibility notes

Merge safety: This plan runs in parallel with Plans 01 and 02 (same wave). Plan 01 modifies `markdown_converter.py`. Plan 02 modifies `jira_api_client.py`, `pyproject.toml`, `jarkdown.py`. **This plan creates ONLY new files: `src/jarkdown/config_manager.py` and `tests/test_config_manager.py`. No shared files with other Wave 1 plans — verified.**

Note: The `tomli` conditional dependency is added to `pyproject.toml` by Plan 02 (which owns all pyproject.toml changes). The CLI arguments `--include-fields` and `--exclude-fields` are also added by Plan 02 (which owns all jarkdown.py changes). This plan only implements the ConfigManager class and its tests.

Design decisions (from 02-CONTEXT.md):
- Config file: `.jarkdown.toml` in current working directory
- CLI flags: `--include-fields` and `--exclude-fields` (comma-separated field names)
- CLI overrides config when both present
- Default: include all custom fields with non-null values

TOML config schema:
```toml
[fields]
include = ["Story Points", "Sprint", "Epic Link"]
exclude = ["Internal Notes"]
```

## Tasks

### Task 1: Implement ConfigManager class

Create `src/jarkdown/config_manager.py`:

```python
"""Configuration manager for jarkdown field selection."""

import logging
import sys
from pathlib import Path

if sys.version_info >= (3, 11):
    import tomllib
else:
    try:
        import tomli as tomllib
    except ImportError:
        tomllib = None


class ConfigManager:
    """Manages field selection configuration from TOML file and CLI args."""

    CONFIG_FILENAME = ".jarkdown.toml"

    def __init__(self, config_dir=None):
        """Initialize the config manager.

        Args:
            config_dir: Directory to search for config file.
                        Defaults to current working directory.
        """
        self.logger = logging.getLogger(__name__)
        self._config_dir = Path(config_dir) if config_dir else Path.cwd()
        self._config = None  # Lazy-loaded

    @property
    def config_path(self):
        """Path to the config file."""
        return self._config_dir / self.CONFIG_FILENAME

    def _load_config(self):
        """Load configuration from TOML file.

        Returns:
            dict: Parsed config dict, or empty dict if file not found.
        """
        if self._config is not None:
            return self._config

        config_path = self.config_path
        if not config_path.exists():
            self._config = {}
            return self._config

        if tomllib is None:
            self.logger.warning(
                "TOML parsing unavailable (install tomli for Python < 3.11). "
                "Config file ignored."
            )
            self._config = {}
            return self._config

        try:
            with open(config_path, "rb") as f:
                self._config = tomllib.load(f)
            self.logger.debug(f"Loaded config from {config_path}")
        except Exception as e:
            self.logger.warning(f"Error reading config file {config_path}: {e}")
            self._config = {}

        return self._config

    def get_field_filter(self, cli_include=None, cli_exclude=None):
        """Get resolved field include/exclude sets.

        CLI args override config file settings. If CLI args are provided,
        config file settings for the same key are ignored entirely.

        Args:
            cli_include: Comma-separated include field names from CLI, or None.
            cli_exclude: Comma-separated exclude field names from CLI, or None.

        Returns:
            dict: {"include": set|None, "exclude": set}
                  include=None means "include all" (default behavior).
                  include=set means "only include these fields".
                  exclude=set of field names to exclude (always a set, may be empty).
        """
        config = self._load_config()
        fields_config = config.get("fields", {})

        # Determine include list
        if cli_include is not None:
            include = {name.strip() for name in cli_include.split(",") if name.strip()}
        elif fields_config.get("include"):
            include = set(fields_config["include"])
        else:
            include = None  # None means "include all"

        # Determine exclude list
        if cli_exclude is not None:
            exclude = {name.strip() for name in cli_exclude.split(",") if name.strip()}
        elif fields_config.get("exclude"):
            exclude = set(fields_config["exclude"])
        else:
            exclude = set()

        return {"include": include, "exclude": exclude}

    @staticmethod
    def should_include_field(field_name, field_filter=None):
        """Check if a field should be included in output.

        Args:
            field_name: Display name of the field.
            field_filter: Pre-computed filter from get_field_filter().
                          If None, defaults to include all.

        Returns:
            bool: True if the field should be included.
        """
        if field_filter is None:
            return True

        # Check exclude first
        if field_name in field_filter.get("exclude", set()):
            return False

        # If include is None (default), include all
        include_set = field_filter.get("include")
        if include_set is None:
            return True

        # Otherwise, only include if in the include set
        return field_name in include_set
```

Commit: `feat(phase-02): implement config manager`

### Task 2: Write config loading and TOML parsing tests

Create `tests/test_config_manager.py` with initial test classes:

```python
import pytest
from jarkdown.config_manager import ConfigManager

@pytest.fixture
def config_dir(tmp_path):
    """Temporary directory for config files."""
    return tmp_path
```

**TestConfigLoading** class:
- `test_load_valid_config`: Write valid `.jarkdown.toml` with `[fields]\ninclude = ["Story Points", "Sprint"]` to tmp_path, create `ConfigManager(config_dir=tmp_path)`, verify `_load_config()` returns `{"fields": {"include": ["Story Points", "Sprint"]}}`
- `test_no_config_file`: No file exists → `_load_config()` returns empty dict, no error
- `test_invalid_toml`: Write `"not valid [[[ toml"` to `.jarkdown.toml` → `_load_config()` returns empty dict, warning logged (use `caplog` fixture to verify)
- `test_empty_config`: Write empty file → empty dict
- `test_config_without_fields_section`: Write TOML with `[other]\nkey = "value"` but no `[fields]` → `get_field_filter()` returns default (include=None, exclude=empty set)

Commit: `test(phase-02): add config loading tests`

### Task 3: Write field filter and precedence tests

Add to `tests/test_config_manager.py`:

**TestFieldFilter** class:
- `test_default_filter`: No config file, no CLI args → `{"include": None, "exclude": set()}`
- `test_config_include_only`: Config with `include = ["Story Points", "Sprint"]` → include={"Story Points", "Sprint"}, exclude=empty set
- `test_config_exclude_only`: Config with `exclude = ["Internal Notes"]` → include=None, exclude={"Internal Notes"}
- `test_config_both_include_exclude`: Config with both lists → both sets populated correctly
- `test_cli_include_overrides_config`: Config has include=["A", "B"], CLI has "C,D" → include={"C", "D"} (CLI wins entirely)
- `test_cli_exclude_overrides_config`: Config has exclude=["A"], CLI has "B" → exclude={"B"} (CLI wins)
- `test_cli_empty_string`: CLI `""` for include → empty set (not None — explicit empty overrides config)
- `test_cli_comma_separated_whitespace`: CLI `"Story Points, Sprint, Epic Link"` → 3-element set with whitespace stripped

**TestShouldIncludeField** class:
- `test_include_all_default`: No filter (None) → all fields return True
- `test_include_specific_fields`: Include={"Story Points"} → "Story Points" True, "Sprint" False
- `test_exclude_specific_field`: Exclude={"Internal Notes"} → "Internal Notes" False, "Story Points" True
- `test_exclude_takes_precedence_over_include`: Field in both include and exclude → excluded (False)
- `test_empty_include_set`: Include=set() (empty set, not None) → no fields included (all return False)

Commit: `test(phase-02): add field filter and precedence tests`

## Verification

```bash
pytest tests/test_config_manager.py -v
pytest tests/test_components.py -v  # existing tests unchanged
```

## Success Criteria

- ConfigManager loads `.jarkdown.toml` with TOML parsing
- Field include/exclude filtering works correctly
- CLI args override config file settings
- Default behavior includes all fields (no config needed)
- TOML import works on Python 3.8-3.12+ with appropriate fallback
- should_include_field is a static method usable by other components
- Invalid/missing config files handled gracefully
- All tests pass (new and existing)
